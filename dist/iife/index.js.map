{"version":3,"sources":["../../node_modules/graphql-request/src/index.ts","../../src/data-provider/index.ts","../../src/utils/index.ts","../../src/index.ts"],"sourcesContent":["import createRequestBody from './createRequestBody.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js'\nimport {\n  parseBatchRequestArgs,\n  parseRawRequestArgs,\n  parseRawRequestExtendedArgs,\n  parseRequestArgs,\n  parseRequestExtendedArgs,\n} from './parseArgs.js'\nimport { resolveRequestDocument } from './resolveRequestDocument.js'\nimport type * as Dom from './types.dom.js'\nimport type {\n  HTTPMethodInput,\n  MaybeFunction,\n  RequestConfig,\n  RequestMiddleware,\n  Response,\n  VariablesAndRequestHeadersArgs,\n} from './types.js'\nimport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from './types.js'\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport crossFetch, * as CrossFetch from 'cross-fetch'\nimport type { T, V } from 'vitest/dist/types-7cd96283.js'\n\nexport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n}\n\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = (headers: Dom.RequestInit['headers']): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n  if (headers) {\n    if (\n      (typeof Headers !== `undefined` && headers instanceof Headers) ||\n      (CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers)\n    ) {\n      oHeaders = HeadersInstanceToPlainObject(headers)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value\n        }\n      })\n    } else {\n      oHeaders = headers as Record<string, string>\n    }\n  }\n\n  return oHeaders\n}\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\ntype BuildRequestConfigParamsBatch<V> = {\n  query: string[]\n  variables: V[] | undefined\n  operationName: undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParamsSingle<V> = {\n  query: string\n  variables: V | undefined\n  operationName: string | undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParams<V> = BuildRequestConfigParamsSingle<V> | BuildRequestConfigParamsBatch<V>\n\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = <V extends Variables>(params: BuildRequestConfigParams<V>): string => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params as BuildRequestConfigParamsSingle<V>\n    const search: string[] = [`query=${encodeURIComponent(cleanQuery(params_.query))}`]\n\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`)\n    }\n\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`)\n    }\n\n    return search.join(`&`)\n  }\n\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`)\n  }\n\n  // Batch support\n  const params_ = params as BuildRequestConfigParamsBatch<V>\n  const payload = params.query.reduce<{ query: string; variables: string | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({\n        query: cleanQuery(currentQuery),\n        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined,\n      })\n      return acc\n    },\n    []\n  )\n\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`\n}\n\ntype Fetch = (url: string, config: Dom.RequestInit) => Promise<Dom.Response>\n\ninterface RequestVerbParams<V extends Variables = Variables> {\n  url: string\n  query: string | string[]\n  fetch: Fetch\n  fetchOptions: Dom.RequestInit\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  middleware?: RequestMiddleware<V>\n}\n\nconst createHttpMethodFetcher =\n  (method: 'GET' | 'POST') =>\n  async <V extends Variables>(params: RequestVerbParams<V>) => {\n    const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params\n\n    const headers = { ...params.headers }\n    let queryParams = ``\n    let body = undefined\n\n    if (method === `POST`) {\n      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer)\n      if (typeof body === `string`) {\n        // @ts-expect-error todo\n        headers[`Content-Type`] = `application/json`\n      }\n    } else {\n      // @ts-expect-error todo needs ADT for TS to understand the different states\n      queryParams = buildRequestConfig<V>({\n        query,\n        variables,\n        operationName,\n        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n      })\n    }\n\n    const init: Dom.RequestInit = {\n      method,\n      headers,\n      body,\n      ...fetchOptions,\n    }\n\n    let urlResolved = url\n    let initResolved = init\n    if (middleware) {\n      const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }))\n      const { url: urlNew, ...initNew } = result\n      urlResolved = urlNew\n      initResolved = initNew\n    }\n    if (queryParams) {\n      urlResolved = `${urlResolved}?${queryParams}`\n    }\n    return await fetch(urlResolved, initResolved)\n  }\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(private url: string, public readonly requestConfig: RequestConfig = {}) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <T, V extends Variables = Variables>(\n    ...args: RawRequestMethodArgs<V>\n  ): Promise<Response<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<V>(queryOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const { operationName } = resolveRequestDocument(rawRequestOptions.query)\n\n    return makeRequest<T, V>({\n      url,\n      query: rawRequestOptions.query,\n      variables: rawRequestOptions.variables as V,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(rawRequestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  async request<T, V extends Variables = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n\n    return makeRequest<T>({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsOptions<V>): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(\n    documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>,\n    requestHeaders?: Dom.RequestInit['headers']\n  ): Promise<T> {\n    const batchRequestOptions = parseBatchRequestArgs<V>(documentsOrOptions, requestHeaders)\n    const { headers, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const queries = batchRequestOptions.documents.map(\n      ({ document }) => resolveRequestDocument(document).query\n    )\n    const variables = batchRequestOptions.documents.map(({ variables }) => variables)\n\n    return makeRequest<T>({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders),\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n      .then((response) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  setHeaders(headers: Dom.RequestInit['headers']): GraphQLClient {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): GraphQLClient {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-ignore\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): GraphQLClient {\n    this.url = value\n    return this\n  }\n}\n\nconst makeRequest = async <T = unknown, V extends Variables = Variables>(params: {\n  url: string\n  query: string | string[]\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  fetch: Fetch\n  method?: HTTPMethodInput\n  fetchOptions: Dom.RequestInit\n  middleware?: RequestMiddleware<V>\n}): Promise<Response<T>> => {\n  const { query, variables, fetchOptions } = params\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`))\n  const isBatchingQuery = Array.isArray(params.query)\n  const response = await fetcher(params)\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer)\n\n  const successfullyReceivedData = Array.isArray(result)\n    ? !result.some(({ data }) => !data)\n    : Boolean(result.data)\n\n  const successfullyPassedErrorPolicy =\n    Array.isArray(result) ||\n    !result.errors ||\n    (Array.isArray(result.errors) && !result.errors.length) ||\n    fetchOptions.errorPolicy === `all` ||\n    fetchOptions.errorPolicy === `ignore`\n\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const { errors, ...rest } = Array.isArray(result) ? result : result\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result\n    const dataEnvelope = isBatchingQuery ? { data } : data\n\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status,\n    }\n  } else {\n    const errorResult =\n      typeof result === `string`\n        ? {\n            error: result,\n          }\n        : result\n    throw new ClientError(\n      // @ts-expect-error TODO\n      { ...errorResult, status: response.status, headers: response.headers },\n      { query, variables }\n    )\n  }\n}\n\n// prettier-ignore\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']]\n  | [RawRequestOptions<V>]\n\n// prettier-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nexport const rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<Response<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\nexport async function request<T, V extends Variables = Variables>(\n  url: string,\n  // @ts-ignore\n  document: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  options: RequestExtendedOptions<V, T>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  urlOrOptions: string | RequestExtendedOptions<V, T>,\n  // @ts-ignore\n  document?: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T> {\n  // @ts-ignore\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nexport const batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\ntype BatchResult = [Result, ...Result[]]\n\n// prettier-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: Dom.RequestInit['headers']]\n  | [options: BatchRequestsExtendedOptions]\n\nconst parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\nexport default request\n\nconst getResult = async (\n  response: Dom.Response,\n  jsonSerializer: Dom.JsonSerializer\n): Promise<\n  | { data: object; errors: undefined }[]\n  | { data: object; errors: undefined }\n  | { data: undefined; errors: object }\n  | { data: undefined; errors: object[] }\n> => {\n  let contentType: string | undefined\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value\n    }\n  })\n\n  if (\n    contentType &&\n    (contentType.toLowerCase().startsWith(`application/json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql+json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql-response+json`))\n  ) {\n    return jsonSerializer.parse(await response.text()) as any\n  } else {\n    return response.text() as any\n  }\n}\n\nconst callOrIdentity = <T>(value: MaybeFunction<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: any[]): string => {\n  return chunks.reduce(\n    (accumulator, chunk, index) => `${accumulator}${chunk}${index in variables ? variables[index] : ``}`,\n    ``\n  )\n}\n\nexport { GraphQLWebSocketClient } from './graphql-ws.js'\nexport { resolveRequestDocument } from './resolveRequestDocument.js'\n","import { BaseRecord } from '@refinedev/core';\nimport { DataProvider } from \"@refinedev/core\";\nimport { GraphQLClient } from \"graphql-request\";\nimport * as gql from \"gql-query-builder\";\nimport pluralize from \"pluralize\";\nimport camelCase from \"camelcase\";\nimport { createNestedInput, generateSort, generateWherePropFromFilters, excludePropsFomObj, includeJustPropsFromObj, updateNestedInput } from '../utils';\n\n\n\n const dataProvider = (client: GraphQLClient): Required<DataProvider> => {\n    return {\n        getList: async (props) => {\n            const { resource, pagination, sorters, filters, meta } = props\n            const singularResource = pluralize.singular(resource);\n            const {\n                current, pageSize, mode = \"server\",\n            } = pagination ?? {};\n\n            const orderBy = generateSort(sorters);\n\n            const where = generateWherePropFromFilters(filters, meta?.nestedFieldsNames, meta?.nestedListFieldsNames);\n            const pascalResource = camelCase(singularResource, { pascalCase: true });\n           \n            const pluralRessource = pluralize(pascalResource)\n            const operation = `all${pluralRessource}`;\n            const operation2 = `_all${pluralRessource}Meta`;\n            const { query, variables } = gql.query([\n                {\n                    operation,\n                    variables: {\n                        where: { value: where, type: `${pascalResource}WhereInput` },\n                        orderBy: { value: orderBy, type: `[${pascalResource}OrderByWithRelationInput!]` },\n                        page: { value: Number(current || 1), required: false, type: 'Float' },\n                        perPage: { value: Number(pageSize || 10), required: false, type: 'Float' }\n                    },\n                    fields: meta?.fields || [],\n                },\n                {\n                    operation: operation2,\n                    variables: {\n                        where: { value: where, type: `${pascalResource}WhereInput` }\n                    },\n                    fields: ['count'],\n                }\n            ]);\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation],\n                total: Number(response[operation2].count),\n            };\n        },\n\n        getMany: async ({ resource, ids, meta }) => {\n            const singularResource = pluralize.singular(resource);\n            const pascalResource = camelCase(singularResource, { pascalCase: true });\n            // const pluralRessource = pluralize(pascalResource)\n            const operation = `all${pascalResource}`;\n\n\n            const { query, variables } = gql.query({\n                operation,\n                variables: {\n                    where: {\n                        value: { id_in: ids },\n                    },\n                },\n                fields: meta?.fields,\n            });\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation],\n            };\n        },\n\n        create: async ({ resource, variables, meta }) => {\n            \n            const singularResource = pluralize.singular(resource);\n            const pascalResource = camelCase(singularResource, { pascalCase: true });\n\n            const camelCreateName = camelCase(`create${pascalResource}`);\n\n            const operation = meta?.operation ?? camelCreateName;\n            // const { nestedFields } = meta as any\n            const nestedFieldsNames = meta?.nestedFieldsNames || [];\n            const nestedVars = includeJustPropsFromObj(variables, nestedFieldsNames);\n            const nestedInput = createNestedInput(nestedVars);\n            const fieldsWithoutNestedInput = excludePropsFomObj(variables, nestedFieldsNames);\n            const { query, variables: gqlVariables } = gql.mutation({\n                operation,\n                variables: {\n                    createInput: {\n                        value: {\n                            ...fieldsWithoutNestedInput,\n                            ...nestedInput\n                        },\n                        type: `${pascalResource}CreateInput!`,\n                    },\n                },\n                fields: meta?.fields,\n            });\n            const response = await client.request<BaseRecord>(\n                query,\n                gqlVariables\n            );\n\n            return {\n                data: response[operation][singularResource],\n            };\n        },\n\n        createMany: async ({ resource, variables, meta }) => {\n            const singularResource = pluralize.singular(resource);\n            const camelCreateName = camelCase(`create${singularResource}`);\n\n            const operation = meta?.operation ?? camelCreateName;\n\n            const response = await Promise.all(\n                variables.map(async (param) => {\n                    const { query, variables: gqlVariables } = gql.mutation({\n                        operation,\n                        variables: {\n                            input: {\n                                value: { data: param },\n                                type: `${camelCreateName}Input`,\n                            },\n                        },\n                        fields: meta?.fields ?? [\n                            {\n                                operation: singularResource,\n                                fields: [\"id\"],\n                                variables: {},\n                            },\n                        ],\n                    });\n                    const result = await client.request<BaseRecord>(\n                        query,\n                        gqlVariables\n                    );\n\n                    return result[operation][singularResource];\n                })\n            );\n            return {\n                data: response,\n            };\n        },\n\n        update: async ({ resource, id, variables, meta }) => {\n            const singularResource = pluralize.singular(resource);\n            const pascalResource = camelCase(singularResource, { pascalCase: true });\n            const pascalUpdateName = camelCase(`update${pascalResource}`);\n\n\n            const operation = meta?.operation ?? pascalUpdateName;\n\n            const initialVariables = {};\n            const nestedFieldsNames = meta?.nestedFieldsNames || [];\n            const nestedVars = includeJustPropsFromObj(variables, nestedFieldsNames);\n            const nestedInput = updateNestedInput(nestedVars, initialVariables);\n            const fieldsWithoutNestedInput = excludePropsFomObj(variables, nestedFieldsNames);\n\n            const { query, variables: gqlVariables } = gql.mutation({\n                operation,\n                variables: {\n                    id: {\n                        value: Number(id),\n                        type: 'Int!'\n                    },\n                    updateInput: {\n                        value: {\n                            ...fieldsWithoutNestedInput,\n                            ...nestedInput\n                        },\n                        type: `${pascalResource}UpdateInput!`,\n                    },\n                },\n                fields: ['id'],\n            });\n            const response = await client.request<BaseRecord>(\n                query,\n                gqlVariables\n            );\n\n            return {\n                data: response[operation][singularResource],\n            };\n        },\n\n        updateMany: async ({ resource, ids, variables, meta }) => {\n            const singularResource = pluralize.singular(resource);\n\n            const pascalResource = camelCase(singularResource, { pascalCase: true });\n            const pascalUpdateName = camelCase(`update${pascalResource}`);\n\n\n            const operation = meta?.operation ?? pascalUpdateName;\n\n            const response = await Promise.all(\n                ids.map(async (id) => {\n                    const { query, variables: gqlVariables } = gql.mutation({\n                        operation,\n                        variables: {\n                            id: {\n                                value: Number(id),\n                                type: 'Int!'\n                            },\n                            updateInput: {\n                                value: {\n                                    ...variables,\n\n                                },\n                                type: `${pascalResource}UpdateInput!`,\n                            },\n                        },\n                        fields: ['id'],\n\n                    });\n                    const result = await client.request<BaseRecord>(\n                        query,\n                        gqlVariables\n                    );\n\n                    return result[operation][singularResource];\n                })\n            );\n            return {\n                data: response,\n            };\n        },\n\n        getOne: async ({ resource, id, meta }) => {\n            const singularResource = pluralize.singular(resource);\n            const pascalResource = camelCase(singularResource, { pascalCase: true });\n\n            const operation = pascalResource;\n\n            const { query, variables } = gql.query({\n                operation,\n                variables: {\n                    id: { value: Number(id), type: \"Int!\" },\n                },\n                fields: meta?.fields || [\"id\"],\n            });\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation],\n            };\n        },\n\n        deleteOne: async ({ resource, id, meta }) => {\n            const singularResource = pluralize.singular(resource);\n            const pascalResource = camelCase(singularResource, { pascalCase: true });\n            const camelDeleteName = camelCase(`delete${pascalResource}`);\n\n            const operation = meta?.operation ?? camelDeleteName;\n\n            const { query, variables } = gql.mutation({\n                operation,\n                variables: {\n                    id: { value: Number(id), type: \"Int!\" },\n                },\n                fields: ['id'],\n            });\n\n            const response = await client.request<BaseRecord>(query, variables);\n\n            return {\n                data: response[operation][singularResource],\n            };\n        },\n\n        deleteMany: async ({ resource, ids, meta }) => {\n            const singularResource = pluralize.singular(resource);\n            const pascalResource = camelCase(singularResource, { pascalCase: true });\n            const camelDeleteName = camelCase(`delete${pascalResource}`);\n\n            const operation = meta?.operation ?? camelDeleteName;\n\n            const response = await Promise.all(\n                ids.map(async (id) => {\n                    const { query, variables: gqlVariables } = gql.mutation({\n                        operation,\n                        variables: {\n                            id: { value: Number(id), type: \"Int!\" },\n                        },\n                        fields: ['id'],\n                    });\n                    const result = await client.request<BaseRecord>(\n                        query,\n                        gqlVariables\n                    );\n\n                    return result[operation][singularResource];\n                })\n            );\n            return {\n                data: response,\n            };\n        },\n\n        getApiUrl: () => {\n            throw Error(\"Not implemented on refine-graphql data provider.\");\n        },\n\n        custom: async ({ url, method, headers, meta }) => {\n            let gqlClient = client;\n\n            if (url) {\n                gqlClient = new GraphQLClient(url, { headers });\n            }\n\n            if (meta) {\n                if (meta.operation) {\n                    if (method === \"get\") {\n                        const { query, variables } = gql.query({\n                            operation: meta.operation,\n                            fields: meta.fields,\n                            variables: meta.variables,\n                        });\n\n                        const response = await gqlClient.request<BaseRecord>(\n                            query,\n                            variables\n                        );\n\n                        return {\n                            data: response[meta.operation],\n                        };\n                    } else {\n                        const { query, variables } = gql.mutation({\n                            operation: meta.operation,\n                            fields: meta.fields,\n                            variables: meta.variables,\n                        });\n\n                        const response = await gqlClient.request<BaseRecord>(\n                            query,\n                            variables\n                        );\n\n                        return {\n                            data: response[meta.operation],\n                        };\n                    }\n                } else {\n                    throw Error(\"GraphQL operation name required.\");\n                }\n            } else {\n                throw Error(\n                    \"GraphQL need to operation, fields and variables values in meta object.\"\n                );\n            }\n        },\n    };\n};\n\n\n\nexport default dataProvider","\nconst itemWithSameIdExists = (itemsList: any[], item: any) => {\n    return itemsList.map((item: any) => item?.id).filter(i => !!i)\n        .indexOf(item?.id) !== -1\n}\n\nexport const createDeleteUpdateFields = (currentData: any, initialData: any) => {\n    const nestedResourcestoBeCreated = currentData.filter((item: any) => !item?.id);\n    const nestedResourcesToBeUpdated = currentData.filter((item: any) => !!item?.id);\n    const nestedResourcestoBeDeleted = initialData.filter((item: any) => !itemWithSameIdExists(currentData, item))\n    return {\n        create: nestedResourcestoBeCreated,\n        update: nestedResourcesToBeUpdated,\n        delete: nestedResourcestoBeDeleted,\n    }\n\n}\n\nexport const updateNestedInput = (nestedFields: any, initialVariables: any) => {\n\n    return Object.entries(nestedFields).reduce((accum, [fieldName, data]) => {\n        return {\n            ...accum,\n            [fieldName]: {\n                ...createDeleteUpdateFields(data, initialVariables[fieldName])\n            }\n        };\n    }, {});\n};\nexport const includeJustPropsFromObj = (obj: any, propList: any) => {\n    return Object.entries(obj).filter(([fieldName, _]) => {\n        return propList.indexOf(fieldName) !== -1\n    })\n        .reduce((accum, [fieldName, data]) => {\n            return {\n                ...accum,\n                [fieldName]: data\n            }\n        }, {})\n}\nexport const excludePropsFomObj = (obj: any, propList: any) => {\n    return Object.entries(obj).filter(([fieldName, _]) => {\n        return propList.indexOf(fieldName) === -1\n    })\n        .reduce((accum, [fieldName, data]) => {\n            return {\n                ...accum,\n                [fieldName]: data\n            }\n        }, {})\n}\nexport const createNestedInput = (nestedFields: any) => {\n\n    return Object.entries(nestedFields).reduce((accum, [fieldName, data]) => {\n        return {\n            ...accum,\n            [fieldName]: {\n                create: data\n            }\n        }\n    }, {})\n}\n\nexport const generateSort = (sorters: any = []) => {\n\n    const sortProp = sorters.map((field: any) => {\n        if (!!field?.field && field?.order) {\n            return {\n                [field?.field]: field?.order\n            }\n        }\n        return null\n    }).filter((r: any) => !!r)\n    return sortProp\n}\n\nexport const generateWherePropFromFilters = (filters: any = [],nestedFieldsNames:any[] = [],nestedListFieldsNames:any[] = []) => {\n    console.log('props from filters....',filters)\n    const whereProp = filters.reduce((accum: any, filter: any) => {\n        if (\n            filter.operator !== \"or\" &&\n            filter.operator !== \"and\" &&\n            \"field\" in filter\n        ) {\n            const { field, operator, value } = filter;\n            console.log(operator,value,'nestedFieldsNames',nestedFieldsNames)\n            if (operator === \"in\" && nestedListFieldsNames.indexOf(field) !==-1) {\n               \n            \n                return {\n                    ...accum,\n                    [field]: { some:{id:{in:value.map((val:string) =>Number(val))}} }\n                } \n            }\n             // todo cehck for non M2m then no some just in\n            if (operator === \"in\" && nestedFieldsNames.indexOf(field) !==-1) {\n               \n            \n                return {\n                    ...accum,\n                    [field]: { is:{id:{in:value.map((val:string) =>Number(val))}} }\n                } \n            }\n            if (operator === \"eq\" && nestedListFieldsNames.indexOf(field) !==-1) {\n           \n                return {\n                    ...accum,\n                    [field]:{some:{id:{equals:Number(value)}}}\n                }\n            }\n            if (operator === \"eq\" && nestedFieldsNames.indexOf(field) !==-1) {\n           \n                return {\n                    ...accum,\n                    [field]:{is:{id:{equals:Number(value)}}}\n                }\n            }\n            \n            if (operator === \"eq\" && nestedFieldsNames.indexOf(field) ===-1 && nestedListFieldsNames.indexOf(field) !==-1) {\n                return {\n                    ...accum,\n                    [field]: { equals: value }\n                }\n            }\n            if ([\"lt\", \"gt\",\"lte\", \"gte\"].indexOf(operator) !== -1) {\n                return {\n                    ...accum,\n                    [field]: { [operator]: value }\n                }\n            }\n\n          \n        }\n\n        return {\n            ...accum\n        }\n    }, { })\n\n    return whereProp\n}","import dataProvider from \"./data-provider\";\nexport default dataProvider;\n\nexport * from \"./data-provider\";\n\n\nexport {\n    GraphQLClient,\n    batchRequests,\n    gql,\n    rawRequest,\n    request,\n    resolveRequestDocument,\n} from \"graphql-request\";\n\nexport type {\n    BatchRequestDocument,\n    BatchRequestsExtendedOptions,\n    BatchRequestsOptions,\n    ClientError,\n    RawRequestExtendedOptions,\n    RawRequestOptions,\n    RequestDocument,\n    RequestExtendedOptions,\n    RequestOptions,\n    Variables,\n} from \"graphql-request\";\n\nexport * as qqlQueryBuilder from \"gql-query-builder\";\n\n\nexport * from \"./utils\";\n"],"mappings":"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","names":["import_createRequestBody","import_defaultJsonSerializer","import_helpers","import_parseArgs","import_resolveRequestDocument","import_types","CrossFetch","import_graphql_ws","resolveHeaders","headers","oHeaders","CrossFetch","name","value","cleanQuery","str","buildRequestConfig","params","params_","search","payload","acc","currentQuery","index","createHttpMethodFetcher","method","url","query","variables","operationName","fetch","fetchOptions","middleware","queryParams","body","createRequestBody","init","urlResolved","initResolved","result","urlNew","initNew","GraphQLClient","requestConfig","args","queryOrOptions","requestHeaders","rawRequestOptions","crossFetch","requestMiddleware","responseMiddleware","makeRequest","callOrIdentity","response","error","documentOrOptions","variablesAndRequestHeaders","requestOptions","documentsOrOptions","batchRequestOptions","queries","document","key","fetcher","isBatchingQuery","getResult","successfullyReceivedData","data","successfullyPassedErrorPolicy","errors","rest","errorResult","rawRequest","urlOrOptions","request","batchRequests","parseBatchRequestsArgsExtended","getResult","response","jsonSerializer","contentType","value","key","callOrIdentity","gql","chunks","variables","accumulator","chunk","index","gql","import_pluralize","import_camelcase","itemWithSameIdExists","itemsList","item","i","createDeleteUpdateFields","currentData","initialData","nestedResourcestoBeCreated","nestedResourcesToBeUpdated","nestedResourcestoBeDeleted","updateNestedInput","nestedFields","initialVariables","accum","fieldName","data","includeJustPropsFromObj","obj","propList","_","excludePropsFomObj","createNestedInput","generateSort","sorters","field","generateWherePropFromFilters","filters","nestedFieldsNames","nestedListFieldsNames","filter","operator","value","val","dataProvider","client","props","resource","pagination","sorters","filters","meta","singularResource","pluralize","current","pageSize","mode","orderBy","generateSort","where","generateWherePropFromFilters","pascalResource","camelCase","pluralRessource","operation","operation2","query","variables","response","ids","camelCreateName","nestedFieldsNames","nestedVars","includeJustPropsFromObj","nestedInput","createNestedInput","fieldsWithoutNestedInput","excludePropsFomObj","gqlVariables","param","id","pascalUpdateName","initialVariables","updateNestedInput","camelDeleteName","url","method","headers","gqlClient","GraphQLClient","data_provider_default","qqlQueryBuilder","src_default","data_provider_default"]}